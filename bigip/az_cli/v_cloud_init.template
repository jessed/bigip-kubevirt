#cloud-config

chpasswd:
  list: |
    root:${rootPass}
    admin:${adminPass}
  expire: False

write_files:
  - path: /config/user_alert.conf
    permissions: 0644
    encoding: b64
    content: ${userAlert}

  - path: /shared/rebind_eth0_driver
    permissions: 0755
    encoding: b64
    content: ${rebindNicDriver}

  - path: /config/tmm_init.tcl
    permissions: 0644
    content: |
      device driver vendor_dev 15b3:101e mlxvf5
      ndal rx_devq_sz 512 15b3:101e
      ndal tx_devq_sz 512 15b3:101e
      #device driver vendor_dev 15b3:101e xnet

  - path: /shared/cloud_init.bash
    permissions: 0755
    content: |
      #! /bin/bash

      # 1 = debugging enabled, 0 = debugging disabled
      DEBUG=1
      # source wait_bigip_ready* functions
      source /usr/lib/bigstart/bigip-ready-functions

      # Declare bash arrays for various configuration elements
      declare -A config
      declare -A mac_map
      declare -A interfaces

      # Hardcode config elements to work-around the lack of config-maps in AODS
      # System-wide variables
      config[hostname]="${hostname}"
      config[dnsServers]="${dnsServers}"
      config[ntpServers]="${ntpServers}"
      config[ntpTimezone]="${ntpTimezone}"
      config[strictpasswords]="${strictPasswords}"
      config[sshPort]="${sshPort}"
      config[regKey]="${regKey}"
      config[pubKey]="${pubKey_b64}"
      config[rebindNicScript]="${rebindNicDriver}"
      config[userAlert]="${userAlert}"
      config[envFile]="${envFile}"
      config[proxyProtocol]="${proxyProtocol}"
      config[proxyAddr]="${proxyAddr}"
      config[proxyPort]="${proxyPort}"
      # Management (CSN) networking
      config[mgmtAddr]="${csnV4addr}"
      config[mgmtCidr]="${csnV4cidr}"
      config[mgmtGtwy]="${csnV4gtwy}"
      # OAM networking
      config[dataVlanName1]="${oamName}"
      config[dataVlanAddr1]="${oamV4addr}"
      config[dataVlanCidr1]="${oamV4cidr}"
      config[dataVlanTag1]="${oamVlanTag}"
      config[dataVlanMac1]="${oamMacAddr}"
      # Client networking
      config[dataVlanName2]="${clientName}"
      config[dataVlanAddr2]="${clientV4addr}"
      config[dataVlanCidr2]="${clientV4cidr}"
      config[dataVlanTag2]="${clientVlanTag}"
      config[dataVlanMac2]="${clientMacAddr}"
      # Server networking
      config[dataVlanName3]="${serverName}"
      config[dataVlanAddr3]="${serverV4addr}"
      config[dataVlanCidr3]="${serverV4cidr}"
      config[dataVlanTag3]="${serverVlanTag}"
      config[dataVlanMac3]="${serverMacAddr}"
      config[dataGtwy]="${dataGtwy}"


      ###
      ### Functions
      ###

      # Configure system global settings
      function update_global() {
        # Disable DHCP if a management-ip was provided in config-map
        if [[ -n ${config[mgmtAddr]} ]]; then
          echo "($(date +%T)) Found management-ip, disabling management DHCP"
          tmsh modify sys global-settings mgmt-dhcp disabled
        fi

        echo "($(date +%T) )Setting hostname to '${config[hostname]}'"
        tmsh modify sys global-settings hostname ${config[hostname]}
        echo "($(date +%T) )Setting DNS servers to ${config[dnsServers]}"
        tmsh modify sys dns name-servers replace-all-with { ${config[dnsServers]} }
        echo "($(date +%T) )Setting timezone to ${config[ntpTimezone]} and NTP servers to ${config[ntpServers]}"
        tmsh modify sys ntp servers replace-all-with { ${config[ntpServers]} } timezone ${config[ntpTimezone]}
        echo "($(date +%T)) Updating scp whitelist to include /shared"
        echo "/shared" >> /config/ssh/scp.whitelist
        tmsh restart sys service sshd

        # If defined, configure proxy host and port 
        if [[ -n ${config[proxyAddr]} ]]; then
          echo "($(date +%T)) Setting proxy.host to ${config[proxyAddr]}"
          tmsh modify sys db proxy.host value ${config[proxyAddr]}
        fi
        if [[ -n ${config[proxyPort]} ]]; then
          echo "($(date +%T)) Setting proxy.host to ${config[proxyPort]}"
          tmsh modify sys db proxy.port value ${config[proxyPort]}
        fi

      # If ssh port is not 22, update to the defined value
      if [[ ${config[sshPort]} != 22 ]]; then tmsh modify sys ssh port ${config[sshPort]}; fi


        if [[ ${config[strictpasswords]} == "disable" ]]; then
          echo "($(date +%T)) Disabling strict password policy"
          tmsh modify sys db users.strictpasswords value ${config[strictpasswords]}
        fi
      }

      # Add $sshKey to admin and root
      function inject_pubkey() {
        if [[ -n ${config[pubKey]} ]]; then
          pubKey=$(printf "%s" ${config[pubKey]} | base64 -d)
          echo "($(date +%T)) Found ssh public key; adding to authorized_keys"
          echo "($(date +%T)) Key: $pubKey"
          echo "$pubKey" >> /var/ssh/root/authorized_keys
          #echo "$pubKey" >> /home/admin/.ssh/authorized_keys
        else
          echo "($(date +%T)) Skipping SSH public key insertion, config[pubKey] not defined"
        fi
      }

      # Assign management-ip only if a mgmtAddr is found in the config-map
      function assign_mgmt_addr() {
        # Assign management addr
        if [[ -n ${config[mgmtAddr]} ]]; then
          echo "($(date +%T)) Deleting default/dhcp management-ip"
          tmsh delete sys management-ip all
          echo "($(date +%T)) Setting management-ip to ${config[mgmtAddr]}"
          tmsh create sys management-ip ${config[mgmtAddr]}/${config[mgmtCidr]}
        fi
        if [[ -n ${config[mgmtGtwy]} ]]; then
          echo "($(date +%T)) Creating management default-route"
          tmsh create sys management-route default gateway ${config[mgmtGtwy]}
        fi
      }

      # create vlans based on mac-addresses provided in the config-map
      function create_dataplane_by_mac() {
        # Find all nics
        nics=$(tmsh show net interface | awk '/^1/ { printf("%s ", $1) }')

        echo "($(date +%T)) Beginning interface identification for interfaces: $nics"
        # First wait for interfaces to be available in case TMM isn't done initializing
        for n in $nics; do
          # Wait up to 120 seconds for the mac addresses to become populated
          for (( count=0; $count < 120; count++)); do
            mac=$(tmsh show net interface $n all-properties | awk '/^1/ { print tolower($3) }')
            if [[ -n $mac && ! $mac =~ "none"  ]]; then
              echo "($(date +%T)) Found mac address for $n ($mac), adding to interface list"
              interfaces[${n#0}]=${mac#0}
              break
            else
              sleep 1
            fi
          done
          if [[ -z ${interfaces[${n#0}]} ]]; then
            echo "($(date +%T)) ERROR: Failed to find mac-address for interface $n"
          fi
        done

        echo "($(date +%T)) Interface identification complete"
        test $DEBUG && {
          tmsh show net interface all-properties
          echo "($(date +%T)) Interfaces mapped:"
          for i in ${!interfaces[@]}; do
            echo "$i -> ${interfaces[$i]}"
          done
        }


        # Associate interface with config-map entries based on index id
        dataVlanMac="dataVlanMac*"
        for n in ${!config[@]}; do
          if [[ ! $n =~ $dataVlanMac ]]; then continue; fi
          # get the index id
          id=${n: -1}
          vlan_mac=$(echo ${config[$n]} | tr -d ':.' | tr [:upper:] [:lower:])
          test $DEBUG && echo "($(date +%T)) Processing dataVlanMac: $n (vlan_mac: $vlan_mac)"

          # Create the mac-address to index mapping
          for i in ${!interfaces[@]}; do
            imac=$(echo ${interfaces[$i]} | tr -d ':.' | tr [:upper:] [:lower:])
            test $DEBUG && echo "($(date +%T)) interface: $i, mac: $imac"
            if [[ ${imac#0} =~ ${vlan_mac#0} ]]; then
              test $DEBUG && echo "($(date +%T)) Associating interface $i (mac: $imac) with index $id (${config[dataVlanMac\${id}]})"
              mac_map[${imac}]=\${id}
              break
            fi
          done
        done

        # Now create the configuration using the interface and the mapped index
        for n in ${!interfaces[@]}; do
          iface=$n
          mac=$(echo ${interfaces[$n]} | tr -d ':.' | tr [:upper:] [:lower:])

          # Make sure this mac exists in the mac_map array
          if [[ ${mac_map[$mac]} == "" ]]; then continue; fi
          id=${mac_map[$mac]}
          vlanAddr=${config[dataVlanAddr\${id}]}
          vlanCidr=${config[dataVlanCidr\${id}]}
          vlanMac=${config[dataVlanMac\${id}]}

          # Define vlan name if none provided
          if [[ -n ${config[dataVlanName\${id}]} ]]; then
            vlanName=${config[dataVlanName\${id}]}
          else
            vlanName=$(printf "vlan%03d" $id)
          fi

          # Define vlan name if none provided
          if [[ -n ${config[dataVlanTag\${id}]} ]]; then
            vlanTag=${config[dataVlanTag\${id}]}
          else
            vlanTag=$((4000 + $id))
          fi


          # Create the vlan
          echo "($(date +%T)) Creating vlan $vlanName (tag: $vlanTag) with interface '$iface'"
          test $DEBUG && echo "tmsh create net vlan $vlanName tag $vlanTag interfaces add { $iface }"
          tmsh create net vlan $vlanName tag $vlanTag interfaces add { $iface }

          # Create the self-ip for that vlan
          echo "($(date +%T)) Create self-IP '$vlanAddr' and assigning to vlan '$vlanName'"
          test $DEBUG && echo "tmsh create net self ${vlanAddr}/${vlanCidr} vlan $vlanName"
          tmsh create net self ${vlanAddr}/${vlanCidr} vlan $vlanName
        done
      }

      # create vlans based on interface order
      function create_dataplane_by_order() {
        nics=$(tmsh show net interface | awk '/^1/ { print $1 }' | cut -d. -f2)

        for n in $nics; do
          if [[ $n == 0 ]]; then continue; fi

          # Define vlan name if none provided
          if [[ -n ${config[dataVlanName\${n}]} ]]; then
            vlanName=${config[dataVlanName\${n}]}
          else
            vlanName=$(printf "vlan%04d" $n)
          fi

          # Define vlan tag if none provided
          if [[ -n ${config[dataVlanTag\${n}]} ]]; then
            vlanTag=${config[dataVlanTag\${n}]}
          else
            vlanTag=$((4000 + $n))
          fi

          echo "Assigning interface 1.$n to vlan $vlanName (tag: $vlanTag)"
          test $DEBUG && echo "tmsh create net vlan $vlanName tag $vlanTag interfaces add { 1.$n }"
          tmsh create net vlan $vlanName tag $vlanTag interfaces add { 1.$n }

          echo "Assigning self-ip ${config[dataVlanAddr\${n}]} to vlan $vlanName"
          test $DEBUG && echo "tmsh create net self ${config[dataVlanAddr\${n}]}/${config[dataVlanCidr\${n}]} vlan $vlanName"
          tmsh create net self ${config[dataVlanAddr\${n}]}/${config[dataVlanCidr\${n}]} vlan $vlanName
        done
      }



      # Assign data-plane gateway
      function create_default_route() {
        if [[ -n ${config[dataGtwy]} ]]; then
          echo "($(date +%T)) Creating default route"
          test $DEBUG && echo "tmsh create net route default gw ${config[dataGtwy]}"
          tmsh create net route default gw ${config[dataGtwy]}
        fi
      }
      
      # Enable managment access to first vlan self-ip
      function enable_mgmt_access() {
        # Allow SSH and management on first self-ip
        if [[ ${config[dataVlanAddr1]} ]]; then
          echo "($(date +%T)) Enabling SSH and HTTPS access to first data-plane IP address"
          test $DEBUG && echo "tmsh modify net self ${config[dataVlanAddr1]}/${config[dataVlanCidr1]} allow-service add { tcp:443 tcp:${config[sshPort]} }"
          tmsh modify net self ${config[dataVlanAddr1]}/${config[dataVlanCidr1]} allow-service add { tcp:443 tcp:${config[sshPort]} }
        fi
      }

      # Bind eth0 to mlx5_core driver
      # This is reset every time TMM is restarted, so we will need a better long-term solution
      function bind_mgmt_interface() {
        # Identify first interface PCI address
        echo "($(date +%T)) Finding first network interface for use with CSN"
        pci_addr="0000:$(lspci | grep -m1 Mellanox | awk '{ print $1 }')"
        echo "($(date +%T)) Found PCI addrss $pci_addr"

        # Add driver override entry
        echo "($(date +%T)) Overriding driver for pci: $pci_addr"
        [[ $DEBUG ]] && echo "($(date +%T)) echo mlx5_core > /sys/bus/pci/devices/\${pci_addr}/driver_override"
        echo mlx5_core > /sys/bus/pci/devices/\${pci_addr}/driver_override

        # forcibly probe that PCI slot
        echo "($(date +%T)) Probing pci address: $pci_addr"
        [[ $DEBUG ]] && echo "($(date +%T)) echo $pci_addr > /sys/bus/pci/drivers/drivers_probe"
        echo $pci_addr > /sys/bus/pci/drivers_probe

        # Add eth0 to mgmt bridge
        echo "($(date +%T)) Adding interface eth0 to mgmt bridge"
        [[ $DEBUG ]] && echo "($(date +%T)) brctl addif mgmt eth0"
        brctl addif mgmt eth0

        # Enable interface
        echo "($(date +%T)) Enabling interface eth0"
        [[ $DEBUG ]] && echo "($(date +%T)) ifconfig eth0 up"
        ifconfig eth0 up
      }


      # Create cli environment file, if defined
      function mk_cli_env() {
        if [[ -n ${config[envFile]} ]]; then
          echo "($(date +%T)) Environment file defined, writing to /shared/env.ltm"
          echo ${config[envFile]} | base64 -d > /shared/env.ltm

          homes="/root /home/admin"

          for home in $homes; do
            echo "source /shared/env.ltm" >> $home/.bash_profile
            sed -i  's!^cd /config!#cd /config!' $home/.bash_profile
          done
        else
          echo "($(date +%T)) Environment file undefined, skipping environment customization"
        fi
      }

      # Restart chmand service - necessary for get_dossier to work (at least for now)
      function restart_chmand() {
        echo "($(date +%T)) Restarting chmand"
        tmsh restart sys service chmand
        sleep 5
      }

      # Apply license
      function activate_license() {
        if [[ -n ${config[regKey]} ]]; then
          echo "($(date +%T)) Attempting to activate license: ${config[regKey]}"
          #if [[ -n ${config[proxyAddr]} && -n ${config[proxyPort]} ]]; then
          #  echo "($(date +%T)) Running SOAPLicenseClient with proxy: ${config[proxyAddr]}:${config[proxyPort]}"
          #  test $DEBUG && echo "SOAPLicenseClient --proxy ${config[proxyAddr]}:${config[proxyPort]} --basekey ${config[regKey]}"
          #  SOAPLicenseClient --proxy ${config[proxyAddr]}:${config[proxyPort]} --basekey ${config[regKey]}
          #else
          #  echo "($(date +%T)) Running SOAPLicenseClient"
            test $DEBUG && echo "SOAPLicenseClient --basekey ${config[regKey]}"
            SOAPLicenseClient --verbose --basekey ${config[regKey]}
          fi
        else
          echo "($(date +%T)) No Registration key defined, skipping license activation"
        fi
      }

      ###
      ### Main
      ###

      # Source bigip ready functions
      source /usr/lib/bigstart/bigip-ready-functions
      # Wait for bigip to be ready to execute
      echo "($(date +%T)) Waiting for BIG-IP to reach ready state"
      wait_bigip_ready
      echo "($(date +%T)) wait_bigip_ready() returned, proceeding with configuration"
      
      update_global
      assign_mgmt_addr
      inject_pubkey
      mk_cli_env

      # If interface mac-addresses were provided in config-map, assign interfaces to vlans
      # based on their mac address. Otherwise, assign interfaces based on presentation order.
      if [[ ${config[dataVlanMac1]} ]]; then
        echo "($(date +%T)) Found 'dataVlanMac1', assigning interfaces to vlans by mac-address"
        create_dataplane_by_mac
      else
        echo "($(date +%T)) 'dataVlanMac1' not found, assigning interfaces to vlans by presentation order"
        create_dataplane_by_order
      fi

      create_default_route
      enable_mgmt_access

      # Save configuration
      echo "($(date +%T)) Saving configuration"
      tmsh save sys config >/dev/null 2>&1

      # run /shared/rebind_eth0_driver to enable mgmt port
      echo "($(date +%T)) Rebinding eth0 to mlx5_core and restarting chmand"
      /shared/rebind_eth0_driver

      # Activate license
      activate_license

runcmd:
  - /shared/cloud_init.bash &

# vim: set syntax=bash tabstop=2 expandtab:
